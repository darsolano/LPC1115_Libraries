
#include <lcd1602.h>
#include <timer32_lpc11xx.h>
#include <mcp23008.h>
#include <stdarg.h>


//Font Generated by MikroElektronika GLCD Font Creator 1.2.0.0
//MikroeElektronika 2011
//http://www.mikroe.com

//HD44780 Alpha Numeric Character Set - FontName : RTC5x8
//HD44780 Alpha Numeric Character Set - FontSize : 5 x 8

const uint8_t RTC5x8[] = {
	0x08, 0x14, 0x08, 0x03, 0x04, 0x07, 0x04, 0x04,  // Code for char num #0 Faranheit
	0x08, 0x14, 0x08, 0x03, 0x04, 0x04, 0x03, 0x00,  // Code for char num #1 Celcius
	0x04, 0x0A, 0x0E, 0x0A, 0x00, 0x1A, 0x15, 0x15,  // Code for char num #2 AM
	0x04, 0x0A, 0x0C, 0x08, 0x00, 0x1A, 0x15, 0x15,  // Code for char num #3 PM
	0x0C, 0x12, 0x12, 0x0C, 0x00, 0x00, 0x00, 0x00,  // Code for char num #4 Degrees
	0x00, 0x01, 0x01, 0x05, 0x05, 0x15, 0x15, 0x00,  // Code for char num #5 Bar
	0x00, 0x15, 0x0E, 0x04, 0x04, 0x04, 0x04, 0x00,  // Code for char num #6 Antenna
	0x0E, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x00   // Code for char num #7 Battery Full
	};

const uint8_t Untitled5x8[] = {
        0x02, 0x05, 0x01, 0x12, 0x07, 0x13, 0x14, 0x13,  // Code for char num #0 - i2c
        0x04, 0x0E, 0x0E, 0x0E, 0x0E, 0x1F, 0x00, 0x04,  // Code for char num #1 - Bell
        0x1C, 0x14, 0x1C, 0x0E, 0x0B, 0x0E, 0x03, 0x02,  // Code for char num #2 - Off
        0x1C, 0x14, 0x1C, 0x00, 0x12, 0x1A, 0x16, 0x00,  // Code for char num #3 - On
        0x01, 0x03, 0x05, 0x09, 0x09, 0x0B, 0x1B, 0x18,  // Code for char num #4 - Music
        0x00, 0x0A, 0x1F, 0x1F, 0x1F, 0x0E, 0x04, 0x00,  // Code for char num #5 - Heart
        0x04, 0x0E, 0x1F, 0x04, 0x04, 0x04, 0x04, 0x00,  // Code for char num #6 - Up
        0x04, 0x04, 0x04, 0x04, 0x1F, 0x0E, 0x04, 0x00   // Code for char num #7 - Down
        };


uint8_t buff[128];
uint8_t lcdbuffer;    // Buffer to hold data to transfer to LCD
uint32_t actualClock;
uint8_t lcd2004_line;


static void Init_LCD1602(void)
{
	MCP23008_IODIR_REG_sType iodir;
	iodir.IODir_reg = 0;
	mcp23008_SetGPIODir(&iodir,LCD1602_I2C_ADDR);

	mcp23008_SetIPOL(0, LCD1602_I2C_ADDR);

	MCP23008_IOCON_REG_sType iocon;
	iocon.DISSLW = 0;
	iocon.HAEN = 1;
	iocon.INTPOL = 1;
	iocon.ODR = 1;
	iocon.SEQOP = 1;
	mcp23008_ConfigIOCON(&iocon, LCD1602_I2C_ADDR);
}


void LCD1602_Init(void)
{
	Init_LCD1602();

	//first init string
	delay32us(TIMER0 , dly_10ms);
	mcp23008_WriteGPIO(0x93, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_10ms);
	mcp23008_WriteGPIO(0x83, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);

	//second init string
	mcp23008_WriteGPIO(0x93, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);
	mcp23008_WriteGPIO(0x83, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);

	//third init string
	mcp23008_WriteGPIO(0x93, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);
	mcp23008_WriteGPIO(0x83, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);

	//fourth init string
	// 4 bits mode, only per indications of initializaton
	mcp23008_WriteGPIO(0x92, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);
	mcp23008_WriteGPIO(0x82, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_5ms);

	// 4 bits mode, only per indications of initializaton
	LCD1602_Write(LCD_FUNCTIONSET | LCD_5x8DOTS| LCD_4BITMODE | LCD_2LINE, RS_CMD);

	// Display ON
	LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYON, RS_CMD);

	// Clear Display,
	LCD1602_Write(LCD_CLEARDISPLAY, RS_CMD);

	// Entry Mode Set
	LCD1602_Write(LCD_ENTRYMODESET | LCD_ENTRYLEFT, RS_CMD);

	// Setup special customs character or fonts
	InitHD44780CustomChars();
}

void LCD1602_SetDisplayOnOff(Bool status)
{
	if (status)
	{
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYON, RS_CMD);
	}
	else
	{
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_DISPLAYOFF, RS_CMD);
	}
}

void LCD1602_SetCursorOnOff(Bool status)
{
	if (status)
	{
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_CURSORON, RS_CMD);
	}
	else
	{
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_CURSOROFF, RS_CMD);
	}
}

void LCD1602_Write(uint8_t data, uint8_t RegSel)
{
//****************************Data upper bits-Nibble***************************
	lcdbuffer = ((data & 0xf0));	//upper nibble
	lcdbuffer >>= 4;
	lcdbuffer |= (RegSel | BL | WRITE_LCD);
	lcdbuffer &= ~EN;
	//***************************
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms );
//***********
	lcdbuffer |= EN;
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms);
//***********
	lcdbuffer &= ~EN;
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms);

//********************************** Lower nibble*******************************
	lcdbuffer = (data & 0x0f);
	lcdbuffer |= RegSel | BL | WRITE_LCD;				// Lower nibble
	lcdbuffer &= ~EN;
	//***************************
	//printf("Buffer is: %x\n",lcdbuffer);
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms );
//***********
	lcdbuffer |= EN;
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms );
//***********
	lcdbuffer &= ~EN;
	mcp23008_WriteGPIO(lcdbuffer, LCD1602_I2C_ADDR);
	delay32us(TIMER0 ,dly_1ms );
}



void LCD1602_SetCursorPos(uint8_t x, uint8_t y)
{
	uint8_t address;

	switch (y)
	{
	case 1:
		address = LCD2004_LINE_1_ADDRESS;
		break;

	case 2:
		address = LCD2004_LINE_2_ADDRESS;
		break;

	default:
		address = LCD2004_LINE_1_ADDRESS;
		break;
	}
	address += x - 1;
	LCD1602_Write(LCD_SETDDRAMADDR | address, RS_CMD);
}

void LCD1602_SetCursorBlink(Bool status)
{
	if (status)
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_BLINKON, RS_CMD);
	else
		LCD1602_Write(LCD_DISPLAYCONTROL | LCD_BLINKOFF, RS_CMD);
}


void LCD1602_SetCursorShift(uint8_t dir)
{
	if (dir == LCD_RIGHT) LCD1602_Write(LCD_DISPLAYCONTROL| LCD_CURSOR_MOVERIGHT , RS_CMD);
	else
		LCD1602_Write(LCD_DISPLAYCONTROL| LCD_CURSOR_MOVELEFT , RS_CMD);
}

void LCD1602_SetDisplayShift(uint8_t dir)
{
	if (dir == LCD_RIGHT) LCD1602_Write(LCD_DISPLAYCONTROL| LCD_DISPLAYMOVE_RIGHT , RS_CMD);
	else
		LCD1602_Write(LCD_DISPLAYCONTROL| LCD_DISPLAYMOVE_LEFT , RS_CMD);
}

void LCD1602_Putc(uint8_t c)
{
	switch (c)
	{
	case '\f':
		LCD1602_Write(LCD_CLEARDISPLAY, RS_CMD);
		lcd2004_line = 1;
		delay32us(TIMER0 ,dly_4us);
		break;

	case '\n':
		LCD1602_Write(++lcd2004_line, RS_DATA);
		break;

	case '\b':
		LCD1602_Write(LCD_CURSOR_DISPLAY_SHIFT | LCD_CURSOR_MOVELEFT, RS_CMD);
		break;

	default:
		LCD1602_Write(c, RS_DATA);
		break;
	}
}

Bool LCD1602_IsLCDBusy(void)
{
	uint8_t data = 0;
	MCP23008_IODIR_REG_sType dir;
	dir.IO3 = input;
	mcp23008_SetGPIODir(&dir , LCD1602_I2C_ADDR);	// Set Direction of bit3 input

	// Read GPIO Bit3 that is Data 7 on LCD for Busy status
	//Only High nibble, no need to read full byte
	data = mcp23008_ReadGPIO(LCD1602_I2C_ADDR) & 0x0f;

	// Set dir back to output of bit 3
	IODIR_Reg_Bits.IODir_reg = 0;
	mcp23008_SetGPIODir(&dir , LCD1602_I2C_ADDR);

	if (data & LCD_BUSY_FLAG) return TRUE;
		else return FALSE;
}

void LCD1602_SetCursorHome()
{				// works OK
	LCD1602_Write(LCD_RETURNHOME, RS_CMD);
}

void LCD1602_SetDisplayClear()
{				// works OK
	LCD1602_Write(LCD_CLEARDISPLAY, RS_CMD);
	LCD1602_SetCursorHome();
}

void LCD1602_Printrs(const char * buffer)
{
	while (*buffer)
	{
		LCD1602_Putc(*buffer++);
	}
}

void LCD1602_Prints(char * buffer)
{
	while (*buffer)
		LCD1602_Putc(*buffer++);
}

/*
 * Define a special custom character to LCD
 * spclchar = array that define the special character
 * charpos = address space in CGRAM to store the character from 0 to 7
 * Character generator solution online at http://mikeyancey.com/hamcalc/lcd_characters.php
 */
void LCD1602_DefineSpecialChars(const char* spclchar, uint8_t charpos)
{
	int8_t idx = 8;
	LCD1602_Write(LCD_SETCGRAMADDR | (charpos*8) , RS_CMD);	// Set CGRAM to first Special font space
	while (idx--)
		LCD1602_Write(*spclchar++ , RS_DATA);
	LCD1602_SetCursorHome();
}


void InitHD44780CustomChars(void)
{
  char i;
  LCD1602_Write(LCD_SETCGRAMADDR,RS_CMD);
  for (i = 0; i <= 63 ; i++)
    LCD1602_Write(RTC5x8[i] , RS_DATA);
  LCD1602_SetCursorHome();
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602 until 99
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutDec99(uint8_t decnum)
{
	uint8_t c1 = decnum % 10;
	uint8_t c2 = (decnum / 10) % 10;
	//uint8_t c3 = (decnum / 100) % 10;
	//LCD1602_Putc('0' + c3);
	LCD1602_Putc('0' + c2);
	LCD1602_Putc('0' + c1);
}


/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutDec(uint8_t decnum)
{
	uint8_t c1 = decnum % 10;
	uint8_t c2 = (decnum / 10) % 10;
	uint8_t c3 = (decnum / 100) % 10;
	if (c3 != 0) LCD1602_Putc('0' + c3);
	if (c2 != 0) LCD1602_Putc('0' + c2);
	LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutDec16(uint16_t decnum)
{
	uint8_t c1 = decnum % 10;
	uint8_t c2 = (decnum / 10) % 10;
	uint8_t c3 = (decnum / 100) % 10;
	uint8_t c4 = (decnum / 1000) % 10;
	uint8_t c5 = (decnum / 10000) % 10;
	if (c5 != 0) LCD1602_Putc('0' + c5);
	if (c4 != 0) LCD1602_Putc('0' + c4);
	if (c3 != 0) LCD1602_Putc('0' + c3);
	if (c2 != 0) LCD1602_Putc('0' + c2);
	LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a decimal number to LCD-1602
 * @param[in]	decnum	Decimal number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutDec32(uint32_t decnum)
{
	uint8_t c1 = decnum % 10;
	uint8_t c2 = (decnum / 10) % 10;
	uint8_t c3 = (decnum / 100) % 10;
	uint8_t c4 = (decnum / 1000) % 10;
	uint8_t c5 = (decnum / 10000) % 10;
	uint8_t c6 = (decnum / 100000) % 10;
	uint8_t c7 = (decnum / 1000000) % 10;
	uint8_t c8 = (decnum / 10000000) % 10;
	uint8_t c9 = (decnum / 100000000) % 10;
	uint8_t c10 = (decnum / 1000000000) % 10;
	if (c10 != 0) LCD1602_Putc('0' + c10);
	if (c9 != 0) LCD1602_Putc('0' + c9);
	if (c8 != 0) LCD1602_Putc('0' + c8);
	if (c7 != 0) LCD1602_Putc('0' + c7);
	if (c6 != 0) LCD1602_Putc('0' + c6);
	if (c5 != 0) LCD1602_Putc('0' + c5);
	if (c4 != 0) LCD1602_Putc('0' + c4);
	if (c3 != 0) LCD1602_Putc('0' + c3);
	if (c2 != 0) LCD1602_Putc('0' + c2);
	LCD1602_Putc('0' + c1);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602 port without the 0x chars
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutHex_(uint8_t hexnum)
{
	uint8_t nibble, i;

	//UARTPuts(UARTx, "0x");
	i = 1;
	do
	{
		nibble = (hexnum >> (4 * i)) & 0x0F;
		LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
	} while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (8-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutHex(uint8_t hexnum)
{
	uint8_t nibble, i;

	LCD1602_Prints("0x");
	i = 1;
	do
	{
		nibble = (hexnum >> (4 * i)) & 0x0F;
		LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
	} while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (16-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutHex16(uint16_t hexnum)
{
	uint8_t nibble, i;

	LCD1602_Prints("0x");
	i = 3;
	do
	{
		nibble = (hexnum >> (4 * i)) & 0x0F;
		LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
	} while (i--);
}

/*********************************************************************//**
 * @brief		Puts a hex number to LCD-1602
 * @param[in]	hexnum	Hex number (32-bit long)
 * @return		None
 **********************************************************************/
void LCD1602PutHex32( uint32_t hexnum)
{
	uint8_t nibble, i;

	LCD1602_Prints("0x");
	i = 7;
	do
	{
		nibble = (hexnum >> (4 * i)) & 0x0F;
		LCD1602_Putc((nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble));
	} while (i--);
}

int LCD1602printf(const char *format, ...)
{
	unsigned int index = 0;
	va_list argptr;

	va_start(argptr, format);

	while(format[index] != '\0')
	{
		if(format[index] == '%')
		{
			index++;

			if(format[index] == '\0')
				return 0;

			switch(format[index])
			{
				case 'd':
					LCD1602PutDec32(va_arg(argptr, int));
					break;
				case 'i':
					LCD1602PutDec32( va_arg(argptr, int));
					break;
				case 'u':
					LCD1602PutDec32(va_arg(argptr, unsigned int));
					break;
				case 'c':
					LCD1602_Putc( va_arg(argptr, int));
					break;
				case 's':
					LCD1602_Prints( va_arg(argptr, char *));
					break;
				case 'x':
					LCD1602PutHex( va_arg(argptr, unsigned int));
					break;
				default:
					LCD1602_Putc(format[index]);
			}
		}
		else
			LCD1602_Putc(format[index]);

		index++;
	}

    va_end(argptr);
    return 0;
}



